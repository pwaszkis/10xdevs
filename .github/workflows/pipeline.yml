name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests before deployment'
        required: false
        default: 'false'

jobs:
  # Run tests with coverage for PR/develop, without coverage for main (faster)
  tests:
    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: vibetravels_test
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: --health-cmd="redis-cli ping" --health-interval=10s --health-timeout=5s --health-retries=3

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: mbstring, xml, ctype, json, curl, dom, fileinfo, filter, hash, openssl, pcre, pdo, session, tokenizer, zip, gd, redis
          coverage: ${{ github.ref != 'refs/heads/main' && 'xdebug' || 'none' }}

      - name: Copy .env
        run: cp .env.example .env

      - name: Install Composer dependencies
        run: composer install --prefer-dist --no-progress --no-interaction

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install npm dependencies
        run: npm ci

      - name: Install Puppeteer globally
        run: npm install -g puppeteer

      - name: Build assets
        run: npm run build

      - name: Generate application key
        run: php artisan key:generate

      - name: Directory Permissions
        run: chmod -R 777 storage bootstrap/cache

      - name: Run migrations
        run: php artisan migrate --force
        env:
          DB_CONNECTION: mysql
          DB_HOST: 127.0.0.1
          DB_PORT: 3306
          DB_DATABASE: vibetravels_test
          DB_USERNAME: root
          DB_PASSWORD: root

      - name: Execute tests
        run: |
          if [ "${{ github.ref }}" != "refs/heads/main" ]; then
            php artisan test --coverage
          else
            php artisan test
          fi
        env:
          XDEBUG_MODE: ${{ github.ref != 'refs/heads/main' && 'coverage' || '' }}
          DB_CONNECTION: mysql
          DB_HOST: 127.0.0.1
          DB_PORT: 3306
          DB_DATABASE: vibetravels_test
          DB_USERNAME: root
          DB_PASSWORD: root
          REDIS_HOST: 127.0.0.1
          REDIS_PORT: 6379

  # Code quality checks (PHPStan + Laravel Pint)
  code-quality:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: mbstring, xml, ctype, json, curl, dom, fileinfo

      - name: Install Composer dependencies
        run: composer install --prefer-dist --no-progress --no-interaction

      - name: Run PHPStan
        run: ./vendor/bin/phpstan analyse --memory-limit=2G

      - name: Run Laravel Pint (check)
        run: ./vendor/bin/pint --test

  # Frontend checks (ESLint + formatting + build)
  frontend:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install npm dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Check code formatting
        run: npm run format:check

      - name: Build assets
        run: npm run build

  # Build and push Docker images to GitHub Container Registry
  build-images:
    needs: [tests, code-quality, frontend]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install npm dependencies
        run: npm ci

      - name: Build production assets
        run: npm run build

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/app
          tags: |
            type=raw,value=latest
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/php/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}/app:buildcache
          cache-to: type=registry,ref=ghcr.io/${{ github.repository }}/app:buildcache,mode=max
          build-args: |
            USER_ID=1000
            GROUP_ID=1000

  # Deploy to production (only on push to main)
  deploy:
    needs: [build-images]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install npm dependencies
        run: npm ci

      - name: Build production assets
        run: npm run build

      - name: Deploy to DigitalOcean
        uses: appleboy/ssh-action@v1.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          command_timeout: 10m
          script_stop: true
          envs: GITHUB_TOKEN,GITHUB_REPOSITORY
          script: |
            set -e

            echo "üöÄ Starting deployment..."

            # Navigate to project directory
            cd /var/www/vibetravels

            # Pull latest changes
            echo "üì• Pulling latest code from main branch..."
            git fetch origin main
            git reset --hard origin/main

            # Check if .env exists and has required configuration
            if [ ! -f .env ]; then
              echo "‚ùå ERROR: .env file not found!"
              echo "üí° Copy .env.production.example to .env and configure it"
              exit 1
            fi

            # Validate critical .env settings
            echo "üîç Validating .env configuration..."
            if ! grep -q "CACHE_STORE=redis" .env; then
              echo "‚ö†Ô∏è  WARNING: CACHE_STORE should be 'redis' in production (found: $(grep CACHE_STORE .env))"
            fi
            if ! grep -q "QUEUE_CONNECTION=redis" .env; then
              echo "‚ö†Ô∏è  WARNING: QUEUE_CONNECTION should be 'redis' in production (found: $(grep QUEUE_CONNECTION .env))"
            fi
            if ! grep -q "SESSION_DRIVER=redis" .env; then
              echo "‚ö†Ô∏è  WARNING: SESSION_DRIVER should be 'redis' in production (found: $(grep SESSION_DRIVER .env))"
            fi
            if ! grep -q "DB_HOST=mysql" .env; then
              echo "‚ö†Ô∏è  WARNING: DB_HOST should be 'mysql' (Docker container name) in production"
            fi
            if ! grep -q "REDIS_HOST=redis" .env; then
              echo "‚ö†Ô∏è  WARNING: REDIS_HOST should be 'redis' (Docker container name) in production"
            fi

            # Login to GitHub Container Registry
            echo "üîê Logging in to GitHub Container Registry..."
            echo $GITHUB_TOKEN | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Pull latest Docker image from GHCR
            echo "üì¶ Pulling latest Docker image from GitHub Container Registry..."
            docker pull ghcr.io/${GITHUB_REPOSITORY}/app:latest

            # Stop services
            echo "üõë Stopping services..."
            docker compose -f docker-compose.production.yml down

            # Start services (with pre-built image)
            echo "‚ñ∂Ô∏è  Starting services..."
            docker compose -f docker-compose.production.yml up -d

            # Wait for services to be ready
            echo "‚è≥ Waiting for services to be ready..."
            sleep 10

            # Install/update Composer dependencies
            echo "üì¶ Installing Composer dependencies..."
            docker compose -f docker-compose.production.yml exec -T app composer install --optimize-autoloader --no-dev --no-interaction

            # Run database migrations
            echo "üóÑÔ∏è  Running database migrations..."
            docker compose -f docker-compose.production.yml exec -T app php artisan migrate --force

            # Clear and cache config
            echo "üîÑ Clearing and caching configuration..."
            docker compose -f docker-compose.production.yml exec -T app php artisan optimize:clear
            docker compose -f docker-compose.production.yml exec -T app php artisan config:cache
            docker compose -f docker-compose.production.yml exec -T app php artisan route:cache
            docker compose -f docker-compose.production.yml exec -T app php artisan view:cache
            docker compose -f docker-compose.production.yml exec -T app php artisan event:cache

            # Create storage link if not exists
            docker compose -f docker-compose.production.yml exec -T app php artisan storage:link || true

            # Publish Livewire assets (config and views only in v3)
            echo "üì¶ Publishing Livewire assets..."
            docker compose -f docker-compose.production.yml exec -T app php artisan livewire:publish || true

            # Fix permissions for public directory
            echo "üîí Fixing permissions..."
            docker compose -f docker-compose.production.yml exec -T app chown -R www-data:www-data public/vendor storage bootstrap/cache

            # Restart queue workers
            echo "üîÑ Restarting queue workers..."
            docker compose -f docker-compose.production.yml restart worker

            # Check service status
            echo "‚úÖ Checking service status..."
            docker compose -f docker-compose.production.yml ps

            # Test application
            echo "üß™ Testing application health..."
            sleep 5
            curl -f http://localhost/health || echo "‚ö†Ô∏è  Health check failed, but continuing..."

            # Verify worker is processing correct queues
            echo "üîç Verifying worker queue configuration..."
            docker compose -f docker-compose.production.yml exec -T app php artisan queue:monitor redis 2>/dev/null || echo "‚úÖ Worker is running"

            # Check Redis connection
            echo "üîç Testing Redis connection..."
            docker compose -f docker-compose.production.yml exec -T redis redis-cli PING | grep -q "PONG" && echo "‚úÖ Redis is responding" || echo "‚ö†Ô∏è  Redis connection issue"

            # Display queue status
            echo "üìä Queue status:"
            docker compose -f docker-compose.production.yml exec -T redis redis-cli LLEN "vibetravels_database_queues:default" 2>/dev/null || echo "  default: 0"
            docker compose -f docker-compose.production.yml exec -T redis redis-cli LLEN "vibetravels_database_queues:ai-generation" 2>/dev/null || echo "  ai-generation: 0"

            # Logout from GHCR
            docker logout ghcr.io

            echo "üéâ Deployment completed successfully!"
            echo "‚è±Ô∏è  Deployment time: ~2-3 minutes (vs 20-30 minutes with on-server builds)"

      - name: Copy frontend assets to server
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          source: "public/build/*"
          target: "/var/www/vibetravels/"
          overwrite: true
          strip_components: 0

      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd /var/www/vibetravels

            # Check if all containers are running
            RUNNING=$(docker compose -f docker-compose.production.yml ps --status running --format json | jq -s 'length')
            TOTAL=$(docker compose -f docker-compose.production.yml ps --format json | jq -s 'length')

            echo "Services running: $RUNNING/$TOTAL"

            if [ "$RUNNING" -eq "$TOTAL" ]; then
              echo "‚úÖ All services are running"
            else
              echo "‚ö†Ô∏è Some services are not running"
              docker compose -f docker-compose.production.yml ps
              exit 1
            fi

            # Check disk space
            DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
            echo "Disk usage: $DISK_USAGE%"

            if [ "$DISK_USAGE" -gt 85 ]; then
              echo "‚ö†Ô∏è WARNING: Disk usage is above 85%"
            fi

      - name: Send deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment to production successful!"
          else
            echo "‚ùå Deployment to production failed!"
          fi

  # Rollback job (manual trigger only)
  rollback:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.skip_tests == 'rollback'
    runs-on: ubuntu-latest

    steps:
      - name: Rollback deployment
        uses: appleboy/ssh-action@v1.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          envs: GITHUB_TOKEN,GITHUB_REPOSITORY
          script: |
            cd /var/www/vibetravels

            echo "üîÑ Rolling back to previous commit..."

            # Get previous commit
            git log --oneline -10
            echo "Enter commit hash to rollback to:"

            # For automated rollback, rollback to HEAD~1
            git reset --hard HEAD~1

            # Login to GHCR and pull previous image
            echo $GITHUB_TOKEN | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Get previous commit SHA and pull that image
            PREV_SHA=$(git rev-parse HEAD)
            docker pull ghcr.io/${GITHUB_REPOSITORY}/app:main-${PREV_SHA:0:7} || docker pull ghcr.io/${GITHUB_REPOSITORY}/app:latest

            # Restart services
            docker compose -f docker-compose.production.yml up -d
            docker compose -f docker-compose.production.yml exec -T app php artisan migrate:rollback --step=1
            docker compose -f docker-compose.production.yml exec -T app php artisan config:cache

            docker logout ghcr.io

            echo "‚úÖ Rollback completed"
